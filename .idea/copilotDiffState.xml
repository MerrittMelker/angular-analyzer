<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;angular-analyzer&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;type&quot;: &quot;commonjs&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;ts-node src/index.ts&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ts-morph&quot;: &quot;^22.0.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/node&quot;: &quot;^24.2.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.0.0&quot;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;angular-analyzer&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;type&quot;: &quot;module&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;ts-node src/index.ts&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ts-morph&quot;: &quot;^22.0.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/node&quot;: &quot;^24.2.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.0.0&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/AngularAnalyzer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/AngularAnalyzer.ts" />
              <option name="originalContent" value="import { Project, SourceFile } from &quot;ts-morph&quot;;&#10;import { ImportAnalyzer } from &quot;./analyzers/ImportAnalyzer.js&quot;;&#10;import { ServiceUsageAnalyzer } from &quot;./analyzers/ServiceUsageAnalyzer.js&quot;;&#10;import { ReportGenerator, AnalysisReport } from &quot;./analyzers/ReportGenerator.js&quot;;&#10;&#10;export interface AnalyzerConfig {&#10;  targetModule?: string;&#10;  sourcePattern?: string;&#10;}&#10;&#10;export class AngularAnalyzer {&#10;  private readonly project: Project;&#10;  private readonly importAnalyzer: ImportAnalyzer;&#10;  private readonly serviceUsageAnalyzer: ServiceUsageAnalyzer;&#10;  private readonly reportGenerator: ReportGenerator;&#10;&#10;  constructor(config: AnalyzerConfig = {}) {&#10;    this.project = new Project();&#10;    this.importAnalyzer = new ImportAnalyzer(config.targetModule);&#10;    this.serviceUsageAnalyzer = new ServiceUsageAnalyzer();&#10;    this.reportGenerator = new ReportGenerator();&#10;  }&#10;&#10;  analyze(sourcePattern: string = &quot;sample/**/*.ts&quot;): AnalysisReport {&#10;    this.project.addSourceFilesAtPaths(sourcePattern);&#10;    const report: AnalysisReport = {};&#10;&#10;    for (const sourceFile of this.project.getSourceFiles()) {&#10;      this.analyzeSourceFile(sourceFile, report);&#10;    }&#10;&#10;    return report;&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    this.reportGenerator.outputReport(report);&#10;  }&#10;&#10;  private analyzeSourceFile(sourceFile: SourceFile, report: AnalysisReport): void {&#10;    const importInfo = this.importAnalyzer.analyzeImports(sourceFile);&#10;    const injectedServices = this.importAnalyzer.analyzeConstructorInjection(&#10;      sourceFile, &#10;      importInfo.namedImports&#10;    );&#10;&#10;    if (Object.keys(injectedServices).length === 0) {&#10;      return; // No relevant services injected, skip this file&#10;    }&#10;&#10;    const classes = sourceFile.getClasses();&#10;    for (const cls of classes) {&#10;      const className = cls.getName();&#10;      if (!className) continue;&#10;&#10;      const serviceUsage = this.serviceUsageAnalyzer.analyzeServiceUsage(&#10;        [cls], &#10;        injectedServices&#10;      );&#10;&#10;      const componentReport = this.reportGenerator.generateReport(&#10;        className,&#10;        sourceFile.getFilePath(),&#10;        serviceUsage&#10;      );&#10;&#10;      if (componentReport) {&#10;        report[className] = componentReport;&#10;      }&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Project, SourceFile, ClassDeclaration } from &quot;ts-morph&quot;;&#10;import { ImportAnalyzer } from &quot;./analyzers/ImportAnalyzer.js&quot;;&#10;import { ServiceUsageAnalyzer } from &quot;./analyzers/ServiceUsageAnalyzer.js&quot;;&#10;import { ReportGenerator, AnalysisReport } from &quot;./analyzers/ReportGenerator.js&quot;;&#10;&#10;export interface AnalyzerConfig {&#10;  targetModule?: string;&#10;  sourcePattern?: string;&#10;}&#10;&#10;export class AngularAnalyzer {&#10;  private readonly project: Project;&#10;  private readonly importAnalyzer: ImportAnalyzer;&#10;  private readonly serviceUsageAnalyzer: ServiceUsageAnalyzer;&#10;  private readonly reportGenerator: ReportGenerator;&#10;&#10;  constructor(config: AnalyzerConfig = {}) {&#10;    this.project = new Project();&#10;    this.importAnalyzer = new ImportAnalyzer(config.targetModule);&#10;    this.serviceUsageAnalyzer = new ServiceUsageAnalyzer();&#10;    this.reportGenerator = new ReportGenerator();&#10;  }&#10;&#10;  analyze(sourcePattern: string = &quot;sample/**/*.ts&quot;): AnalysisReport {&#10;    this.project.addSourceFilesAtPaths(sourcePattern);&#10;    const report: AnalysisReport = {};&#10;&#10;    for (const sourceFile of this.project.getSourceFiles()) {&#10;      this.analyzeSourceFile(sourceFile, report);&#10;    }&#10;&#10;    return report;&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    this.reportGenerator.outputReport(report);&#10;  }&#10;&#10;  private analyzeSourceFile(sourceFile: SourceFile, report: AnalysisReport): void {&#10;    const importInfo = this.importAnalyzer.analyzeImports(sourceFile);&#10;    const injectedServices = this.importAnalyzer.analyzeConstructorInjection(&#10;      sourceFile, &#10;      importInfo.namedImports&#10;    );&#10;&#10;    if (Object.keys(injectedServices).length === 0) {&#10;      return; // No relevant services injected, skip this file&#10;    }&#10;&#10;    const classes = sourceFile.getClasses();&#10;    for (const cls of classes) {&#10;      const className = cls.getName();&#10;      if (!className) continue;&#10;&#10;      const serviceUsage = this.serviceUsageAnalyzer.analyzeServiceUsage(&#10;        [cls], &#10;        injectedServices&#10;      );&#10;&#10;      const componentReport = this.reportGenerator.generateReport(&#10;        className,&#10;        sourceFile.getFilePath(),&#10;        serviceUsage&#10;      );&#10;&#10;      if (componentReport) {&#10;        report[className] = componentReport;&#10;      }&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/analyzers/ImportAnalyzer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/analyzers/ImportAnalyzer.ts" />
              <option name="updatedContent" value="import { ImportDeclaration, SourceFile } from &quot;ts-morph&quot;;&#10;&#10;export interface ImportInfo {&#10;  namedImports: Set&lt;string&gt;;&#10;  injectedServices: Record&lt;string, string&gt;; // varName =&gt; className&#10;}&#10;&#10;export class ImportAnalyzer {&#10;  private readonly targetModule: string;&#10;&#10;  constructor(targetModule: string = &quot;tn-api&quot;) {&#10;    this.targetModule = targetModule;&#10;  }&#10;&#10;  analyzeImports(sourceFile: SourceFile): ImportInfo {&#10;    const importsFromTargetModule = this.getTargetModuleImports(sourceFile);&#10;    const namedImports = this.extractNamedImports(importsFromTargetModule);&#10;    &#10;    return {&#10;      namedImports,&#10;      injectedServices: {}&#10;    };&#10;  }&#10;&#10;  analyzeConstructorInjection(sourceFile: SourceFile, namedImports: Set&lt;string&gt;): Record&lt;string, string&gt; {&#10;    const injectedServices: Record&lt;string, string&gt; = {};&#10;    &#10;    const classes = sourceFile.getClasses();&#10;    for (const cls of classes) {&#10;      const constructor = cls.getConstructors()[0];&#10;      if (!constructor) continue;&#10;&#10;      for (const param of constructor.getParameters()) {&#10;        const type = param.getType().getSymbol()?.getName();&#10;        const varName = param.getName();&#10;&#10;        if (type &amp;&amp; namedImports.has(type)) {&#10;          injectedServices[varName] = type;&#10;        }&#10;      }&#10;    }&#10;&#10;    return injectedServices;&#10;  }&#10;&#10;  private getTargetModuleImports(sourceFile: SourceFile): ImportDeclaration[] {&#10;    return sourceFile.getImportDeclarations().filter(decl =&gt;&#10;      decl.getModuleSpecifierValue() === this.targetModule&#10;    );&#10;  }&#10;&#10;  private extractNamedImports(importDeclarations: ImportDeclaration[]): Set&lt;string&gt; {&#10;    return new Set(&#10;      importDeclarations.flatMap(decl =&gt;&#10;        decl.getNamedImports().map(named =&gt; named.getName())&#10;      )&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/analyzers/ReportGenerator.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/analyzers/ReportGenerator.ts" />
              <option name="originalContent" value="import { ServiceUsage } from &quot;./analyzers/ServiceUsageAnalyzer.js&quot;;&#10;&#10;export interface ComponentReport {&#10;  file: string;&#10;  services: Record&lt;string, string[]&gt;;&#10;}&#10;&#10;export interface AnalysisReport {&#10;  [componentName: string]: ComponentReport;&#10;}&#10;&#10;export class ReportGenerator {&#10;  generateReport(&#10;    componentName: string,&#10;    filePath: string,&#10;    serviceUsage: ServiceUsage&#10;  ): ComponentReport | null {&#10;    if (Object.keys(serviceUsage).length === 0) {&#10;      return null;&#10;    }&#10;&#10;    return {&#10;      file: filePath,&#10;      services: this.convertSetsToArrays(serviceUsage)&#10;    };&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    console.log(JSON.stringify(report, null, 2));&#10;  }&#10;&#10;  private convertSetsToArrays(serviceUsage: ServiceUsage): Record&lt;string, string[]&gt; {&#10;    return Object.fromEntries(&#10;      Object.entries(serviceUsage).map(([serviceClass, methods]) =&gt; [&#10;        serviceClass,&#10;        Array.from(methods)&#10;      ])&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ServiceUsage } from &quot;./ServiceUsageAnalyzer.js&quot;;&#10;&#10;export interface ComponentReport {&#10;  file: string;&#10;  services: Record&lt;string, string[]&gt;;&#10;}&#10;&#10;export interface AnalysisReport {&#10;  [componentName: string]: ComponentReport;&#10;}&#10;&#10;export class ReportGenerator {&#10;  generateReport(&#10;    componentName: string,&#10;    filePath: string,&#10;    serviceUsage: ServiceUsage&#10;  ): ComponentReport | null {&#10;    if (Object.keys(serviceUsage).length === 0) {&#10;      return null;&#10;    }&#10;&#10;    return {&#10;      file: filePath,&#10;      services: this.convertSetsToArrays(serviceUsage)&#10;    };&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    console.log(JSON.stringify(report, null, 2));&#10;  }&#10;&#10;  private convertSetsToArrays(serviceUsage: ServiceUsage): Record&lt;string, string[]&gt; {&#10;    return Object.fromEntries(&#10;      Object.entries(serviceUsage).map(([serviceClass, methods]) =&gt; [&#10;        serviceClass,&#10;        Array.from(methods as Set&lt;string&gt;)&#10;      ])&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/analyzers/ServiceUsageAnalyzer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/analyzers/ServiceUsageAnalyzer.ts" />
              <option name="originalContent" value="import { Class, SyntaxKind } from &quot;ts-morph&quot;;&#10;&#10;export interface ServiceUsage {&#10;  [serviceClass: string]: Set&lt;string&gt;; // service class =&gt; method names&#10;}&#10;&#10;export class ServiceUsageAnalyzer {&#10;  analyzeServiceUsage(classes: Class[], injectedServices: Record&lt;string, string&gt;): ServiceUsage {&#10;    const usage: ServiceUsage = {};&#10;&#10;    for (const cls of classes) {&#10;      this.analyzeClassMethods(cls, injectedServices, usage);&#10;    }&#10;&#10;    return usage;&#10;  }&#10;&#10;  private analyzeClassMethods(&#10;    cls: Class, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    for (const method of cls.getMethods()) {&#10;      method.forEachDescendant(node =&gt; {&#10;        if (node.getKind() === SyntaxKind.CallExpression) {&#10;          this.analyzeMethodCall(node, injectedServices, usage);&#10;        }&#10;      });&#10;    }&#10;  }&#10;&#10;  private analyzeMethodCall(&#10;    node: any, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    const callExpr = node.asKind(SyntaxKind.CallExpression);&#10;    if (!callExpr) return;&#10;&#10;    const expr = callExpr.getExpression();&#10;    if (!expr || expr.getKind() !== SyntaxKind.PropertyAccessExpression) return;&#10;&#10;    const serviceInstance = expr.getFirstChildByKind(SyntaxKind.Identifier)?.getText();&#10;    const methodName = expr.getLastChildByKind(SyntaxKind.Identifier)?.getText();&#10;&#10;    const serviceClass = serviceInstance &amp;&amp; injectedServices[serviceInstance];&#10;    if (serviceClass &amp;&amp; methodName) {&#10;      if (!usage[serviceClass]) {&#10;        usage[serviceClass] = new Set();&#10;      }&#10;      usage[serviceClass].add(methodName);&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ClassDeclaration, SyntaxKind, Node } from &quot;ts-morph&quot;;&#10;&#10;export interface ServiceUsage {&#10;  [serviceClass: string]: Set&lt;string&gt;; // service class =&gt; method names&#10;}&#10;&#10;export class ServiceUsageAnalyzer {&#10;  analyzeServiceUsage(classes: ClassDeclaration[], injectedServices: Record&lt;string, string&gt;): ServiceUsage {&#10;    const usage: ServiceUsage = {};&#10;&#10;    for (const cls of classes) {&#10;      this.analyzeClassMethods(cls, injectedServices, usage);&#10;    }&#10;&#10;    return usage;&#10;  }&#10;&#10;  private analyzeClassMethods(&#10;    cls: ClassDeclaration, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    for (const method of cls.getMethods()) {&#10;      method.forEachDescendant((node: Node) =&gt; {&#10;        if (node.getKind() === SyntaxKind.CallExpression) {&#10;          this.analyzeMethodCall(node, injectedServices, usage);&#10;        }&#10;      });&#10;    }&#10;  }&#10;&#10;  private analyzeMethodCall(&#10;    node: Node, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    const callExpr = node.asKind(SyntaxKind.CallExpression);&#10;    if (!callExpr) return;&#10;&#10;    const expr = callExpr.getExpression();&#10;    if (!expr || expr.getKind() !== SyntaxKind.PropertyAccessExpression) return;&#10;&#10;    const serviceInstance = expr.getFirstChildByKind(SyntaxKind.Identifier)?.getText();&#10;    const methodName = expr.getLastChildByKind(SyntaxKind.Identifier)?.getText();&#10;&#10;    const serviceClass = serviceInstance &amp;&amp; injectedServices[serviceInstance];&#10;    if (serviceClass &amp;&amp; methodName) {&#10;      if (!usage[serviceClass]) {&#10;        usage[serviceClass] = new Set();&#10;      }&#10;      usage[serviceClass].add(methodName);&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="originalContent" value="import { Project, SyntaxKind } from &quot;ts-morph&quot;;&#10;&#10;const project = new Project();&#10;project.addSourceFilesAtPaths(&quot;sample/**/*.ts&quot;);&#10;&#10;const report: Record&lt;string, any&gt; = {};&#10;&#10;for (const sourceFile of project.getSourceFiles()) {&#10;  const importsFromTnApi = sourceFile.getImportDeclarations().filter(decl =&gt;&#10;      decl.getModuleSpecifierValue() === &quot;tn-api&quot;&#10;  );&#10;&#10;  const tnApiImports = new Set(&#10;      importsFromTnApi.flatMap(decl =&gt;&#10;          decl.getNamedImports().map(named =&gt; named.getName())&#10;      )&#10;  );&#10;&#10;  const classes = sourceFile.getClasses();&#10;&#10;  for (const cls of classes) {&#10;    const className = cls.getName();&#10;    if (!className) continue;&#10;&#10;    const constructor = cls.getConstructors()[0];&#10;    if (!constructor) continue;&#10;&#10;    // Map of injected identifier name =&gt; class name&#10;    const tnApiInjected: Record&lt;string, string&gt; = {};&#10;&#10;    for (const param of constructor.getParameters()) {&#10;      const type = param.getType().getSymbol()?.getName();&#10;      const varName = param.getName();&#10;&#10;      if (type &amp;&amp; tnApiImports.has(type)) {&#10;        tnApiInjected[varName] = type;&#10;      }&#10;    }&#10;&#10;    // Walk method bodies for service method calls&#10;    const usage: Record&lt;string, Set&lt;string&gt;&gt; = {};&#10;    for (const method of cls.getMethods()) {&#10;      method.forEachDescendant(node =&gt; {&#10;        if (node.getKind() === SyntaxKind.CallExpression) {&#10;          const callExpr = node.asKind(SyntaxKind.CallExpression);&#10;          if (!callExpr) return;&#10;&#10;          const expr = callExpr.getExpression();&#10;          if (!expr || expr.getKind() !== SyntaxKind.PropertyAccessExpression) return;&#10;&#10;          const serviceInstance = expr.getFirstChildByKind(SyntaxKind.Identifier)?.getText();&#10;          const methodName = expr.getLastChildByKind(SyntaxKind.Identifier)?.getText();&#10;&#10;          const serviceClass = serviceInstance &amp;&amp; tnApiInjected[serviceInstance];&#10;          if (serviceClass &amp;&amp; methodName) {&#10;            if (!usage[serviceClass]) {&#10;              usage[serviceClass] = new Set();&#10;            }&#10;            usage[serviceClass].add(methodName);&#10;          }&#10;        }&#10;      });&#10;    }&#10;&#10;    if (Object.keys(usage).length &gt; 0) {&#10;      report[className] = {&#10;        file: sourceFile.getFilePath(),&#10;        services: Object.fromEntries(&#10;            Object.entries(usage).map(([k, v]) =&gt; [k, Array.from(v)])&#10;        )&#10;      };&#10;    }&#10;  }&#10;}&#10;&#10;console.log(JSON.stringify(report, null, 2));&#10;" />
              <option name="updatedContent" value="import { AngularAnalyzer } from &quot;./AngularAnalyzer.js&quot;;&#10;&#10;// Create analyzer with default configuration&#10;const analyzer = new AngularAnalyzer({&#10;  targetModule: &quot;tn-api&quot;,&#10;  sourcePattern: &quot;sample/**/*.ts&quot;&#10;});&#10;&#10;// Analyze the codebase&#10;const report = analyzer.analyze();&#10;&#10;// Output the results&#10;analyzer.outputReport(report);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="originalContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;Node&quot;,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true&#10;  },&#10;  &quot;include&quot;: [&quot;src&quot;]&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;Node&quot;,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true&#10;  },&#10;  &quot;include&quot;: [&quot;src&quot;],&#10;  &quot;ts-node&quot;: {&#10;    &quot;esm&quot;: true&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>