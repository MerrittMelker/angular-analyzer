<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;angular-analyzer&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;type&quot;: &quot;module&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;ts-node src/index.ts&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ts-morph&quot;: &quot;^22.0.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/node&quot;: &quot;^24.2.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.0.0&quot;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;angular-analyzer&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;type&quot;: &quot;module&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;start&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;npm run test:basic &amp;&amp; npm run test:validation&quot;,&#10;    &quot;test:basic&quot;: &quot;echo 'Running basic analysis test...' &amp;&amp; ts-node src/index.ts&quot;,&#10;    &quot;test:validation&quot;: &quot;echo 'Running validation tests...' &amp;&amp; ts-node -e \&quot;import('./src/test-runner.js')\&quot;&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;ts-morph&quot;: &quot;^22.0.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/node&quot;: &quot;^24.2.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.0.0&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/AngularAnalyzer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/AngularAnalyzer.ts" />
              <option name="originalContent" value="import { Project, SourceFile, ClassDeclaration } from &quot;ts-morph&quot;;&#10;import { ImportAnalyzer } from &quot;./analyzers/ImportAnalyzer.js&quot;;&#10;import { ServiceUsageAnalyzer } from &quot;./analyzers/ServiceUsageAnalyzer.js&quot;;&#10;import { ReportGenerator, AnalysisReport } from &quot;./analyzers/ReportGenerator.js&quot;;&#10;&#10;export interface AnalyzerConfig {&#10;  targetModule?: string;&#10;  sourcePattern?: string;&#10;}&#10;&#10;export class AngularAnalyzer {&#10;  private readonly project: Project;&#10;  private readonly importAnalyzer: ImportAnalyzer;&#10;  private readonly serviceUsageAnalyzer: ServiceUsageAnalyzer;&#10;  private readonly reportGenerator: ReportGenerator;&#10;&#10;  constructor(config: AnalyzerConfig = {}) {&#10;    this.project = new Project();&#10;    this.importAnalyzer = new ImportAnalyzer(config.targetModule);&#10;    this.serviceUsageAnalyzer = new ServiceUsageAnalyzer();&#10;    this.reportGenerator = new ReportGenerator();&#10;  }&#10;&#10;  analyze(sourcePattern: string = &quot;sample/**/*.ts&quot;): AnalysisReport {&#10;    this.project.addSourceFilesAtPaths(sourcePattern);&#10;    const report: AnalysisReport = {};&#10;&#10;    for (const sourceFile of this.project.getSourceFiles()) {&#10;      this.analyzeSourceFile(sourceFile, report);&#10;    }&#10;&#10;    return report;&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    this.reportGenerator.outputReport(report);&#10;  }&#10;&#10;  private analyzeSourceFile(sourceFile: SourceFile, report: AnalysisReport): void {&#10;    const importInfo = this.importAnalyzer.analyzeImports(sourceFile);&#10;    const injectedServices = this.importAnalyzer.analyzeConstructorInjection(&#10;      sourceFile, &#10;      importInfo.namedImports&#10;    );&#10;&#10;    if (Object.keys(injectedServices).length === 0) {&#10;      return; // No relevant services injected, skip this file&#10;    }&#10;&#10;    const classes = sourceFile.getClasses();&#10;    for (const cls of classes) {&#10;      const className = cls.getName();&#10;      if (!className) continue;&#10;&#10;      const serviceUsage = this.serviceUsageAnalyzer.analyzeServiceUsage(&#10;        [cls], &#10;        injectedServices&#10;      );&#10;&#10;      const componentReport = this.reportGenerator.generateReport(&#10;        className,&#10;        sourceFile.getFilePath(),&#10;        serviceUsage&#10;      );&#10;&#10;      if (componentReport) {&#10;        report[className] = componentReport;&#10;      }&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Project, SourceFile, ClassDeclaration } from &quot;ts-morph&quot;;&#10;import { ImportAnalyzer } from &quot;./analyzers/ImportAnalyzer.js&quot;;&#10;import { ServiceUsageAnalyzer } from &quot;./analyzers/ServiceUsageAnalyzer.js&quot;;&#10;import { ReportGenerator, AnalysisReport } from &quot;./analyzers/ReportGenerator.js&quot;;&#10;&#10;export interface AnalyzerConfig {&#10;  targetModule?: string;&#10;  sourcePattern?: string;&#10;}&#10;&#10;export class AngularAnalyzer {&#10;  private readonly project: Project;&#10;  private readonly importAnalyzer: ImportAnalyzer;&#10;  private readonly serviceUsageAnalyzer: ServiceUsageAnalyzer;&#10;  private readonly reportGenerator: ReportGenerator;&#10;&#10;  constructor(config: AnalyzerConfig = {}) {&#10;    this.project = new Project();&#10;    this.importAnalyzer = new ImportAnalyzer(config.targetModule);&#10;    this.serviceUsageAnalyzer = new ServiceUsageAnalyzer();&#10;    this.reportGenerator = new ReportGenerator();&#10;  }&#10;&#10;  analyze(sourcePattern: string = &quot;sample/**/*.ts&quot;): AnalysisReport {&#10;    this.project.addSourceFilesAtPaths(sourcePattern);&#10;    const report: AnalysisReport = {};&#10;&#10;    console.log(`Found ${this.project.getSourceFiles().length} source files`);&#10;&#10;    for (const sourceFile of this.project.getSourceFiles()) {&#10;      console.log(`Analyzing file: ${sourceFile.getFilePath()}`);&#10;      this.analyzeSourceFile(sourceFile, report);&#10;    }&#10;&#10;    console.log(`Final report:`, Object.keys(report));&#10;    return report;&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    this.reportGenerator.outputReport(report);&#10;  }&#10;&#10;  private analyzeSourceFile(sourceFile: SourceFile, report: AnalysisReport): void {&#10;    const importInfo = this.importAnalyzer.analyzeImports(sourceFile);&#10;    const injectedServices = this.importAnalyzer.analyzeConstructorInjection(&#10;      sourceFile, &#10;      importInfo.namedImports&#10;    );&#10;&#10;    if (Object.keys(injectedServices).length === 0) {&#10;      return; // No relevant services injected, skip this file&#10;    }&#10;&#10;    const classes = sourceFile.getClasses();&#10;    for (const cls of classes) {&#10;      const className = cls.getName();&#10;      if (!className) continue;&#10;&#10;      const serviceUsage = this.serviceUsageAnalyzer.analyzeServiceUsage(&#10;        [cls], &#10;        injectedServices&#10;      );&#10;&#10;      const componentReport = this.reportGenerator.generateReport(&#10;        className,&#10;        sourceFile.getFilePath(),&#10;        serviceUsage&#10;      );&#10;&#10;      if (componentReport) {&#10;        report[className] = componentReport;&#10;      }&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/analyzers/ImportAnalyzer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/analyzers/ImportAnalyzer.ts" />
              <option name="originalContent" value="import { ImportDeclaration, SourceFile } from &quot;ts-morph&quot;;&#10;&#10;export interface ImportInfo {&#10;  namedImports: Set&lt;string&gt;;&#10;  injectedServices: Record&lt;string, string&gt;; // varName =&gt; className&#10;}&#10;&#10;export class ImportAnalyzer {&#10;  private readonly targetModule: string;&#10;&#10;  constructor(targetModule: string = &quot;tn-api&quot;) {&#10;    this.targetModule = targetModule;&#10;  }&#10;&#10;  analyzeImports(sourceFile: SourceFile): ImportInfo {&#10;    const importsFromTargetModule = this.getTargetModuleImports(sourceFile);&#10;    const namedImports = this.extractNamedImports(importsFromTargetModule);&#10;    &#10;    return {&#10;      namedImports,&#10;      injectedServices: {}&#10;    };&#10;  }&#10;&#10;  analyzeConstructorInjection(sourceFile: SourceFile, namedImports: Set&lt;string&gt;): Record&lt;string, string&gt; {&#10;    const injectedServices: Record&lt;string, string&gt; = {};&#10;    &#10;    const classes = sourceFile.getClasses();&#10;    for (const cls of classes) {&#10;      const constructor = cls.getConstructors()[0];&#10;      if (!constructor) continue;&#10;&#10;      for (const param of constructor.getParameters()) {&#10;        const type = param.getType().getSymbol()?.getName();&#10;        const varName = param.getName();&#10;&#10;        if (type &amp;&amp; namedImports.has(type)) {&#10;          injectedServices[varName] = type;&#10;        }&#10;      }&#10;    }&#10;&#10;    return injectedServices;&#10;  }&#10;&#10;  private getTargetModuleImports(sourceFile: SourceFile): ImportDeclaration[] {&#10;    return sourceFile.getImportDeclarations().filter(decl =&gt;&#10;      decl.getModuleSpecifierValue() === this.targetModule&#10;    );&#10;  }&#10;&#10;  private extractNamedImports(importDeclarations: ImportDeclaration[]): Set&lt;string&gt; {&#10;    return new Set(&#10;      importDeclarations.flatMap(decl =&gt;&#10;        decl.getNamedImports().map(named =&gt; named.getName())&#10;      )&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ImportDeclaration, SourceFile } from &quot;ts-morph&quot;;&#10;&#10;export interface ImportInfo {&#10;  namedImports: Set&lt;string&gt;;&#10;  injectedServices: Record&lt;string, string&gt;; // varName =&gt; className&#10;}&#10;&#10;export class ImportAnalyzer {&#10;  private readonly targetModule: string;&#10;&#10;  constructor(targetModule: string = &quot;tn-api&quot;) {&#10;    this.targetModule = targetModule;&#10;  }&#10;&#10;  analyzeImports(sourceFile: SourceFile): ImportInfo {&#10;    const importsFromTargetModule = this.getTargetModuleImports(sourceFile);&#10;    const namedImports = this.extractNamedImports(importsFromTargetModule);&#10;    &#10;    console.log(`  File: ${sourceFile.getBaseName()}`);&#10;    console.log(`  Found ${importsFromTargetModule.length} imports from ${this.targetModule}`);&#10;    console.log(`  Named imports:`, Array.from(namedImports));&#10;    &#10;    return {&#10;      namedImports,&#10;      injectedServices: {}&#10;    };&#10;  }&#10;&#10;  analyzeConstructorInjection(sourceFile: SourceFile, namedImports: Set&lt;string&gt;): Record&lt;string, string&gt; {&#10;    const injectedServices: Record&lt;string, string&gt; = {};&#10;    &#10;    const classes = sourceFile.getClasses();&#10;    console.log(`  Found ${classes.length} classes`);&#10;    &#10;    for (const cls of classes) {&#10;      const constructor = cls.getConstructors()[0];&#10;      if (!constructor) {&#10;        console.log(`  Class ${cls.getName()} has no constructor`);&#10;        continue;&#10;      }&#10;&#10;      console.log(`  Class ${cls.getName()} constructor has ${constructor.getParameters().length} parameters`);&#10;      &#10;      for (const param of constructor.getParameters()) {&#10;        const type = param.getType().getSymbol()?.getName();&#10;        const varName = param.getName();&#10;        &#10;        console.log(`    Param: ${varName}, Type: ${type}, Is tn-api: ${type &amp;&amp; namedImports.has(type)}`);&#10;&#10;        if (type &amp;&amp; namedImports.has(type)) {&#10;          injectedServices[varName] = type;&#10;        }&#10;      }&#10;    }&#10;&#10;    console.log(`  Injected services:`, injectedServices);&#10;    return injectedServices;&#10;  }&#10;&#10;  private getTargetModuleImports(sourceFile: SourceFile): ImportDeclaration[] {&#10;    return sourceFile.getImportDeclarations().filter(decl =&gt;&#10;      decl.getModuleSpecifierValue() === this.targetModule&#10;    );&#10;  }&#10;&#10;  private extractNamedImports(importDeclarations: ImportDeclaration[]): Set&lt;string&gt; {&#10;    return new Set(&#10;      importDeclarations.flatMap(decl =&gt;&#10;        decl.getNamedImports().map(named =&gt; named.getName())&#10;      )&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/analyzers/ReportGenerator.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/analyzers/ReportGenerator.ts" />
              <option name="originalContent" value="import { ServiceUsage } from &quot;./analyzers/ServiceUsageAnalyzer.js&quot;;&#10;&#10;export interface ComponentReport {&#10;  file: string;&#10;  services: Record&lt;string, string[]&gt;;&#10;}&#10;&#10;export interface AnalysisReport {&#10;  [componentName: string]: ComponentReport;&#10;}&#10;&#10;export class ReportGenerator {&#10;  generateReport(&#10;    componentName: string,&#10;    filePath: string,&#10;    serviceUsage: ServiceUsage&#10;  ): ComponentReport | null {&#10;    if (Object.keys(serviceUsage).length === 0) {&#10;      return null;&#10;    }&#10;&#10;    return {&#10;      file: filePath,&#10;      services: this.convertSetsToArrays(serviceUsage)&#10;    };&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    console.log(JSON.stringify(report, null, 2));&#10;  }&#10;&#10;  private convertSetsToArrays(serviceUsage: ServiceUsage): Record&lt;string, string[]&gt; {&#10;    return Object.fromEntries(&#10;      Object.entries(serviceUsage).map(([serviceClass, methods]) =&gt; [&#10;        serviceClass,&#10;        Array.from(methods)&#10;      ])&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ServiceUsage } from &quot;./ServiceUsageAnalyzer.js&quot;;&#10;&#10;export interface ComponentReport {&#10;  file: string;&#10;  services: Record&lt;string, string[]&gt;;&#10;}&#10;&#10;export interface AnalysisReport {&#10;  [componentName: string]: ComponentReport;&#10;}&#10;&#10;export class ReportGenerator {&#10;  generateReport(&#10;    componentName: string,&#10;    filePath: string,&#10;    serviceUsage: ServiceUsage&#10;  ): ComponentReport | null {&#10;    if (Object.keys(serviceUsage).length === 0) {&#10;      return null;&#10;    }&#10;&#10;    return {&#10;      file: filePath,&#10;      services: this.convertSetsToArrays(serviceUsage)&#10;    };&#10;  }&#10;&#10;  outputReport(report: AnalysisReport): void {&#10;    console.log(JSON.stringify(report, null, 2));&#10;  }&#10;&#10;  private convertSetsToArrays(serviceUsage: ServiceUsage): Record&lt;string, string[]&gt; {&#10;    return Object.fromEntries(&#10;      Object.entries(serviceUsage).map(([serviceClass, methods]) =&gt; [&#10;        serviceClass,&#10;        Array.from(methods as Set&lt;string&gt;)&#10;      ])&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/analyzers/ServiceUsageAnalyzer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/analyzers/ServiceUsageAnalyzer.ts" />
              <option name="originalContent" value="import { Class, SyntaxKind } from &quot;ts-morph&quot;;&#10;&#10;export interface ServiceUsage {&#10;  [serviceClass: string]: Set&lt;string&gt;; // service class =&gt; method names&#10;}&#10;&#10;export class ServiceUsageAnalyzer {&#10;  analyzeServiceUsage(classes: Class[], injectedServices: Record&lt;string, string&gt;): ServiceUsage {&#10;    const usage: ServiceUsage = {};&#10;&#10;    for (const cls of classes) {&#10;      this.analyzeClassMethods(cls, injectedServices, usage);&#10;    }&#10;&#10;    return usage;&#10;  }&#10;&#10;  private analyzeClassMethods(&#10;    cls: Class, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    for (const method of cls.getMethods()) {&#10;      method.forEachDescendant(node =&gt; {&#10;        if (node.getKind() === SyntaxKind.CallExpression) {&#10;          this.analyzeMethodCall(node, injectedServices, usage);&#10;        }&#10;      });&#10;    }&#10;  }&#10;&#10;  private analyzeMethodCall(&#10;    node: any, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    const callExpr = node.asKind(SyntaxKind.CallExpression);&#10;    if (!callExpr) return;&#10;&#10;    const expr = callExpr.getExpression();&#10;    if (!expr || expr.getKind() !== SyntaxKind.PropertyAccessExpression) return;&#10;&#10;    const serviceInstance = expr.getFirstChildByKind(SyntaxKind.Identifier)?.getText();&#10;    const methodName = expr.getLastChildByKind(SyntaxKind.Identifier)?.getText();&#10;&#10;    const serviceClass = serviceInstance &amp;&amp; injectedServices[serviceInstance];&#10;    if (serviceClass &amp;&amp; methodName) {&#10;      if (!usage[serviceClass]) {&#10;        usage[serviceClass] = new Set();&#10;      }&#10;      usage[serviceClass].add(methodName);&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ClassDeclaration, SyntaxKind, Node } from &quot;ts-morph&quot;;&#10;&#10;export interface ServiceUsage {&#10;  [serviceClass: string]: Set&lt;string&gt;; // service class =&gt; method names&#10;}&#10;&#10;export class ServiceUsageAnalyzer {&#10;  analyzeServiceUsage(classes: ClassDeclaration[], injectedServices: Record&lt;string, string&gt;): ServiceUsage {&#10;    const usage: ServiceUsage = {};&#10;&#10;    for (const cls of classes) {&#10;      this.analyzeClassMethods(cls, injectedServices, usage);&#10;    }&#10;&#10;    return usage;&#10;  }&#10;&#10;  private analyzeClassMethods(&#10;    cls: ClassDeclaration, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    for (const method of cls.getMethods()) {&#10;      method.forEachDescendant((node: Node) =&gt; {&#10;        if (node.getKind() === SyntaxKind.CallExpression) {&#10;          this.analyzeMethodCall(node, injectedServices, usage);&#10;        }&#10;      });&#10;    }&#10;  }&#10;&#10;  private analyzeMethodCall(&#10;    node: Node, &#10;    injectedServices: Record&lt;string, string&gt;, &#10;    usage: ServiceUsage&#10;  ): void {&#10;    const callExpr = node.asKind(SyntaxKind.CallExpression);&#10;    if (!callExpr) return;&#10;&#10;    const expr = callExpr.getExpression();&#10;    if (!expr || expr.getKind() !== SyntaxKind.PropertyAccessExpression) return;&#10;&#10;    const serviceInstance = expr.getFirstChildByKind(SyntaxKind.Identifier)?.getText();&#10;    const methodName = expr.getLastChildByKind(SyntaxKind.Identifier)?.getText();&#10;&#10;    const serviceClass = serviceInstance &amp;&amp; injectedServices[serviceInstance];&#10;    if (serviceClass &amp;&amp; methodName) {&#10;      if (!usage[serviceClass]) {&#10;        usage[serviceClass] = new Set();&#10;      }&#10;      usage[serviceClass].add(methodName);&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="originalContent" value="import { Project, SyntaxKind } from &quot;ts-morph&quot;;&#10;&#10;const project = new Project();&#10;project.addSourceFilesAtPaths(&quot;sample/**/*.ts&quot;);&#10;&#10;const report: Record&lt;string, any&gt; = {};&#10;&#10;for (const sourceFile of project.getSourceFiles()) {&#10;  const importsFromTnApi = sourceFile.getImportDeclarations().filter(decl =&gt;&#10;      decl.getModuleSpecifierValue() === &quot;tn-api&quot;&#10;  );&#10;&#10;  const tnApiImports = new Set(&#10;      importsFromTnApi.flatMap(decl =&gt;&#10;          decl.getNamedImports().map(named =&gt; named.getName())&#10;      )&#10;  );&#10;&#10;  const classes = sourceFile.getClasses();&#10;&#10;  for (const cls of classes) {&#10;    const className = cls.getName();&#10;    if (!className) continue;&#10;&#10;    const constructor = cls.getConstructors()[0];&#10;    if (!constructor) continue;&#10;&#10;    // Map of injected identifier name =&gt; class name&#10;    const tnApiInjected: Record&lt;string, string&gt; = {};&#10;&#10;    for (const param of constructor.getParameters()) {&#10;      const type = param.getType().getSymbol()?.getName();&#10;      const varName = param.getName();&#10;&#10;      if (type &amp;&amp; tnApiImports.has(type)) {&#10;        tnApiInjected[varName] = type;&#10;      }&#10;    }&#10;&#10;    // Walk method bodies for service method calls&#10;    const usage: Record&lt;string, Set&lt;string&gt;&gt; = {};&#10;    for (const method of cls.getMethods()) {&#10;      method.forEachDescendant(node =&gt; {&#10;        if (node.getKind() === SyntaxKind.CallExpression) {&#10;          const callExpr = node.asKind(SyntaxKind.CallExpression);&#10;          if (!callExpr) return;&#10;&#10;          const expr = callExpr.getExpression();&#10;          if (!expr || expr.getKind() !== SyntaxKind.PropertyAccessExpression) return;&#10;&#10;          const serviceInstance = expr.getFirstChildByKind(SyntaxKind.Identifier)?.getText();&#10;          const methodName = expr.getLastChildByKind(SyntaxKind.Identifier)?.getText();&#10;&#10;          const serviceClass = serviceInstance &amp;&amp; tnApiInjected[serviceInstance];&#10;          if (serviceClass &amp;&amp; methodName) {&#10;            if (!usage[serviceClass]) {&#10;              usage[serviceClass] = new Set();&#10;            }&#10;            usage[serviceClass].add(methodName);&#10;          }&#10;        }&#10;      });&#10;    }&#10;&#10;    if (Object.keys(usage).length &gt; 0) {&#10;      report[className] = {&#10;        file: sourceFile.getFilePath(),&#10;        services: Object.fromEntries(&#10;            Object.entries(usage).map(([k, v]) =&gt; [k, Array.from(v)])&#10;        )&#10;      };&#10;    }&#10;  }&#10;}&#10;&#10;console.log(JSON.stringify(report, null, 2));&#10;" />
              <option name="updatedContent" value="import { AngularAnalyzer } from &quot;./AngularAnalyzer.js&quot;;&#10;&#10;// Create analyzer with default configuration&#10;const analyzer = new AngularAnalyzer({&#10;  targetModule: &quot;tn-api&quot;,&#10;  sourcePattern: &quot;sample/**/*.ts&quot;&#10;});&#10;&#10;// Analyze the codebase&#10;const report = analyzer.analyze();&#10;&#10;// Output the results&#10;analyzer.outputReport(report);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test-runner.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test-runner.ts" />
              <option name="updatedContent" value="// Test runner to validate all analyzer functionality&#10;import { AngularAnalyzer } from './AngularAnalyzer.js';&#10;import { ImportAnalyzer } from './analyzers/ImportAnalyzer.js';&#10;import { ServiceUsageAnalyzer } from './analyzers/ServiceUsageAnalyzer.js';&#10;import { ReportGenerator } from './analyzers/ReportGenerator.js';&#10;&#10;async function runValidationTests() {&#10;    console.log(' Running Angular Analyzer Validation Tests...\n');&#10;    &#10;    let passedTests = 0;&#10;    let totalTests = 0;&#10;&#10;    function test(name: string, assertion: boolean) {&#10;        totalTests++;&#10;        if (assertion) {&#10;            console.log(`✅ ${name}`);&#10;            passedTests++;&#10;        } else {&#10;            console.log(`❌ ${name}`);&#10;        }&#10;    }&#10;&#10;    try {&#10;        // Test 1: Basic analyzer instantiation&#10;        const analyzer = new AngularAnalyzer();&#10;        test(&quot;AngularAnalyzer instantiation&quot;, analyzer !== undefined);&#10;&#10;        // Test 2: Analyze sample files&#10;        const results = await analyzer.analyze();&#10;        test(&quot;Analysis completes without errors&quot;, results !== undefined);&#10;&#10;        // Test 3: Check that results contain expected component&#10;        const hasAddressEditComponent = 'AddressEditComponent' in results;&#10;        test(&quot;Finds AddressEditComponent&quot;, hasAddressEditComponent);&#10;&#10;        if (hasAddressEditComponent) {&#10;            const component = results.AddressEditComponent;&#10;            &#10;            // Test 4: Component has file path&#10;            test(&quot;Component has file path&quot;, component.file !== undefined);&#10;            &#10;            // Test 5: Component has services&#10;            test(&quot;Component has services&quot;, Object.keys(component.services).length &gt; 0);&#10;            &#10;            // Test 6: CountriesService is detected&#10;            test(&quot;CountriesService detected&quot;, 'CountriesService' in component.services);&#10;            &#10;            // Test 7: Service methods are detected&#10;            if ('CountriesService' in component.services) {&#10;                const methods = component.services.CountriesService;&#10;                test(&quot;CountriesService has methods&quot;, methods.length &gt; 0);&#10;                test(&quot;GetDefault method detected&quot;, methods.includes('GetDefault'));&#10;            }&#10;        }&#10;&#10;        // Test 8: Custom configuration works&#10;        const customAnalyzer = new AngularAnalyzer({&#10;            targetModule: &quot;tn-api&quot;,&#10;            sourcePattern: &quot;sample/**/*.ts&quot;&#10;        });&#10;        test(&quot;Custom configuration accepted&quot;, customAnalyzer !== undefined);&#10;&#10;        console.log(`\n Test Results: ${passedTests}/${totalTests} tests passed`);&#10;        &#10;        if (passedTests === totalTests) {&#10;            console.log(' All tests passed! The analyzer is working correctly.');&#10;        } else {&#10;            console.log('⚠️  Some tests failed. Please check the implementation.');&#10;            process.exit(1);&#10;        }&#10;&#10;    } catch (error) {&#10;        console.error('❌ Test execution failed:', error);&#10;        process.exit(1);&#10;    }&#10;}&#10;&#10;runValidationTests();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="originalContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;Node&quot;,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true&#10;  },&#10;  &quot;include&quot;: [&quot;src&quot;]&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;ESNext&quot;,&#10;    &quot;moduleResolution&quot;: &quot;Node&quot;,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;allowSyntheticDefaultImports&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;strict&quot;: true&#10;  },&#10;  &quot;include&quot;: [&quot;src&quot;],&#10;  &quot;ts-node&quot;: {&#10;    &quot;esm&quot;: true&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>